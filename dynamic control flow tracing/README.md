# Dynamic Control Flow Tracing

## Introduction

This pintool will trace the control flow of the executed instructions by instrumenting the execution of every instruction. When each instruction is executed, this pintool will save what instruction preceded it. 

This pintool does all the tracing in memory and only write to an output dot directed graph file, which represents the control flow of all the observed instructions, in the finish function of the pintool. Each node in the dot directed graph file is the address of an instruction that was executed (only one node per instructino address). The edges in the dot directed graph file go from each executed instruction to the instructions which executed immediately after it.

## Sample

Assume the pintool observes the following sequence of executed instruction addresses: 0x634, 0x636, 0x634, 0x640. The dot directed graph file generated by this tool should be as follows:

```
digraph controlflow {
    "0x634" -> "0x636";
    "0x634" -> "0x640";
    "0x636" -> "0x634";
}
```

## Practice

Here I applied this pintool to a simple backdoor malware: webc2-greencat-2. After starting the C&C server and connecting remotely to the malware, which is set up on a sandbox, this pintool traced every instruction that the malware executed. In order to get every possible C&C command this malware supported, I just statically analyzed this malware and found them all through disassembly. And the pintool also avoids tracing instructions executed in those library functions, which are meaningless for this malware analysis.

